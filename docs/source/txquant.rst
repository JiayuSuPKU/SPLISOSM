Isoform Quantification for ST Data
===========================================

This page provides guidance on obtaining isoform-level quantifications from various spatial transcriptomics (ST) platforms, a prerequisite for running SPLISOSM. If you already have isoform-level quantification results, feel free to skip this section.

We recommend storing isoform quantification results in an AnnData object with the shape ``(n_spot, n_isoform)``, separate from any gene-level AnnData object. SPLISOSM expects the isoform-level AnnData object to have the following structure:

- ``adata.layers['counts']``: A layer containing the raw isoform-level counts.
- ``adata.var``: An isoform-level metadata table with at least the following columns:
    - ``gene_symbol``: The gene symbol corresponding to each isoform.
    - A unique feature identifier, stored in ``adata.var_names`` or a column like ``feature_id`` (e.g., transcript ID, peak ID, codeword ID).
- ``adata.obs``: A spot- or cell-level metadata table with at least the following columns for spatial information:
    - ``array_row``: The spatial row coordinate.
    - ``array_col``: The spatial column coordinate.


Long-read spatial transcriptomics data
-------------------------------------------

If you are working with long-read spatial transcriptomics data, you have likely already performed full-length isoform quantification. SPLISOSM is compatible with *any* upstream long-read isoform quantification tool that produces a count matrix of isoforms across spatial spots or cells. Popular options include `IsoQuant <https://ablab.github.io/IsoQuant/>`_ and `kallisto <https://pachterlab.github.io/kallisto/>`_.

When selecting a quantification tool and its parameters, remember that SPLISOSM's detection power is sensitive to sequencing depth. Specifically, :ref:`the number of significant results increases linearly with the number of captured UMIs per spot <faq:umi-depth>`. Therefore, any method that improves the recovery of RNA reads is expected to enhance SPLISOSM's performance.

Short-read 3' end spatial transcriptomics data
-------------------------------------------------

If you have 3' end short-read spatial transcriptomics data, we recommend using `Sierra <https://github.com/VCCRI/Sierra/tree/master>`_ to extract transcriptome 3' end diversity (TREND) events *de novo*. For detailed instructions on installing and running Sierra, please refer to its `official documentation <https://github.com/VCCRI/Sierra/wiki/Sierra-Vignette>`_.

.. note::

    If you are processing multiple samples, we strongly advise against using Sierra's ``MergePeakCoordinates`` function, as it can sometimes generate overlapping peak definitions.

.. warning::
    
    Some ST protocols, such as 10x Visium FFPE, use targeted gene panels, and thus do not provide information on 3' end variability.

We have successfully tested Sierra on the following ST protocols and expect it to work on other similar platforms:

- 10x Visium (fresh-frozen)
- Slide-seqV2

Running Sierra on BAM generated by 10x SpaceRanger
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: r

   # load the R package 
   library(Sierra)
   FindPeaks(
     output.file = '${peak_file}',
     gtf.file = '${gtf_file}', # SpaceRanger reference gtf file
     bamfile = '${bam_file}',  # bam file from SpaceRanger
     junctions.file = '${junc_file}', # junctions bed files extracted using regtools junctions extract
   # optional arguments for retainning low-abundance peaks
   #   min.jcutoff.prop = 0.0,
   #   min.cov.prop = 0.0,
   #   min.peak.prop = 0.0
   )

   CountPeaks(
     peak.sites.file = '${peak_file}',
     gtf.file = '${gtf_file}',
     bamfile = '${bam_file}',
     whitelist.file = '${whitelist_file}', # barcodes.tsv file from SpaceRanger
     output.dir = '${output_dir}',
   )


Converting Sierra outputs to AnnData
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: python

    import scanpy as sc
    import pandas as pd
    from splisosm.utils import load_visium_sp_meta

    sierra_out_dir = "path/to/sierra/output"  # 'output.dir' in CountPeaks
    sp_meta_dir = "path/to/visium/spatial/metadata"  # 'spatial' directory in 10X Visium data

    # load the Sierra outputs as an AnnData object
    adata = sc.read(
        f"{sierra_out_dir}/matrix.mtx.gz",
        cache_compression='cache_compression',
    ).T

    # load TREND peak metadata
    peaks = pd.read_csv(
        f"{sierra_out_dir}/sitenames.tsv.gz",
        header=None,
        sep="\t",
    )
    df_var = peaks[0].str.split(':', expand=True)
    df_var.columns = ['gene_symbol', 'chr', 'position', 'strand']
    df_var.index = peaks[0].values

    # load spatial barcode metadata
    barcodes = pd.read_csv(f"{sierra_out_dir}/barcodes.tsv.gz", header=None)

    # add metadata to the AnnData object
    adata.var_names = peaks[0].values
    adata.obs_names = barcodes[0].values
    adata.var = df_var
    adata.var['gene_id'] = adata.var['gene_symbol']

    # load Visium spatial metadata
    adata = load_visium_sp_meta(adata, f"{sp_meta_dir}/", library_id='adata_peak')
    adata = adata[adata.obs['in_tissue'].astype(bool), :].copy()

SPLISOSM is agnostic to the specific structure of isoforms or TREND events and will compare all events associated with the same gene. 
For computational efficiency, we recommend filtering out low-abundance isoforms or events before running the analysis.

.. code-block:: python

    # filter out lowly expressed peaks
    sc.pp.filter_genes(adata, min_cells=0.01 * adata.shape[0])

    # extract gene symbols and peak ids
    df_iso_meta = adata.var.copy()  # gene_symbol, chr, position, strand, gene_id
    df_iso_meta['peak_id'] = adata.var_names

    # prepare gene-level metadata
    df_gene_meta = df_iso_meta.groupby('gene_symbol').size().reset_index(name='n_peak')
    df_gene_meta = df_gene_meta.set_index('gene_symbol')

    print(f"Number of spots: {adata.shape[0]}")
    print(f"Number of genes before QC: {df_gene_meta.shape[0]}")
    print(f"Number of peaks before QC: {adata.shape[1]}")
    print(f"Average number of peaks per gene before QC: {adata.shape[1] / df_gene_meta.shape[0]}")

    # calculate the total counts per gene
    mapping_matrix = pd.get_dummies(df_iso_meta['gene_symbol'])
    mapping_matrix = mapping_matrix.loc[df_iso_meta.index, df_gene_meta.index]
    isog_counts = adata[:, mapping_matrix.index].layers['counts'] @ mapping_matrix

    # calculate mean and sd of total gene counts
    df_gene_meta['pct_spot_on'] = (isog_counts > 0).mean(axis=0)
    df_gene_meta['count_avg'] = isog_counts.mean(axis=0)
    df_gene_meta['count_std'] = isog_counts.std(axis=0)

    # filter out lowly expressed genes
    _gene_keep = df_gene_meta['pct_spot_on'] > 0.01
    # _gene_keep = (df_gene_meta['count_avg'] > 0.5) & _gene_keep

    # filter out genes with single isoform
    _gene_keep = (df_gene_meta['n_peak'] > 1) & _gene_keep

    # filter for isoforms
    _iso_keep = df_iso_meta['gene_symbol'].isin(df_gene_meta.index[_gene_keep])

    # update feature meta
    df_gene_meta = df_gene_meta.loc[_gene_keep, :]
    adata = adata[:, _iso_keep]
    adata.var = df_iso_meta.loc[_iso_keep, :].copy()

    print(f"Number of genes after QC: {sum(_gene_keep)}")
    print(f"Number of peaks after QC: {sum(_iso_keep)}")
    print(f"Average number of peaks per gene after QC: {sum(_iso_keep) / sum(_gene_keep)}")


In situ hybridization-based spatial transcriptomics data
----------------------------------------------------------
When working with imaging-based ST data that uses exon- or junction-specific probes, SPLISOSM can be run on either segmented cell-level data or spatially binned spot-level data.

For data from platforms like the `10x Xenium Prime 5K panel <https://www.10xgenomics.com/products/xenium-5k-panel>`_, we provide a `helper script to extract codeword-level quantifications from the 'transcripts.zarr.zip' file <https://github.com/JiayuSuPKU/SPLISOSM/blob/main/scripts/extract_xenium_codeword_dist.py>`_. 
This script bins the transcript data into spots of a user-defined size. It has been tested with outputs from Xenium Ranger v3.1.1.

.. code-block:: zsh

   # download the 'transcripts.zarr.zip' file from 10x Xenium data
   $ wget <Xenium_transcripts_zarr_url> -O transcripts.zarr.zip

   # run the helper script to extract codeword counts and bin into spots
   # estimated runtime: ~15 minutes for a full Xenium 5K dataset, 64GB RAM recommended
   $ python scripts/extract_xenium_codeword_dist.py \
       --data_dir <where_transcripts_zarr_zip_is> \
       --res_dir <output_directory> \
       --spatial_resolution 20 # specify the desired spot size in microns
       --n_jobs 16 # number of parallel threads

   # the output file '<output_directory>/codeword_quant_res_20um.h5ad' is an AnnData object of (n_spot, n_codeword)
   # and can be used as input to SPLISOSM


